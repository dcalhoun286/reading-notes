# Reading Assignment - Class 08

## Preview - Preparation Materials

### [Role-Based Access Control YouTube Tutorial](https://www.youtube.com/watch?v=C4NP8Eon3cA)

- In enterprise setting, access may be baesd on job function or role of a user. These access rights are associated with roles, not directly with user
- Users authenticate themselves to the system
- Users then can activate one or more roles for themselves
- Policy doesn't need to be updated when a certain person (user) with a role leaves the organization
- Damage containment: least amount of privilege necessary for the role
  - User in one role has access to a subset of the files; switch roles to gain access to other resources

### [5 Steps to RBAC](https://www.csoonline.com/article/3060780/5-steps-to-simple-role-based-access-control.html)

- **Inventory your systems**: figure out which recourses need access control
- **Analyze your workforce and create roles**: group members into roles with common access needs.
- **Assign people to roles**: figure out which role(s) each employee belongs in, and set their access acordingly
- **Never make one-off changes**: Change the roles as required or add new ones when really necessary
-- **Audit**: Periodically review your roles, the employees assigned to them, and the access permitted for each

### [wiki - RBAC](https://en.wikipedia.org/wiki/Role-based_access_control)

- Three primary rules defined for RBAC:
  - Role assignment: a subject can exercise a permission only if the subject has selected or been assigned a role
  - Role authorization: A subject's active role must be authorized for the subject. With rule 1 above, this rule ensures that users can take on only roles for which they are authorized.
  - Permission authorization: A subject can exercise a permission only if the permission is authorized for the subject's active role.

## Review, Research, and Discussion

### Document the following vocabulary terms

- **encryption**:Security placed on sensitive data by turning it into a code, thereby disguising the true meaning of the data
- **token**: this piece of information, along with verification of the correct user/device, authorizes the client to make certain URL requests that will otherwise be denied. A token is created/given after information such as username/password have been verified.
- **bearer**: a bearer token is a secret string generated by the server that is sent by the client after login credentials have been confirmed.
  - Resource: [Swagger.io](https://swagger.io/docs/specification/authentication/bearer-authentication/)
- **secret**: This is used by OAuth as an extra layer of encryption, doing so in such a way that makes it virtually impossible to decode. Only the OAuth program itself and the authorization server are aware of this code's meaning.
- **JSON Web Token**: This is passed in the authorization header of a `POST` request. This is generated/given via secret on the server side to the browser after a user's credential are confirmed, to be used to validate an HTTP request
  - Resource: [JWTs Explained](https://www.youtube.com/watch?v=926mknSW9Lo)

### Answer the following prompts and cite any external resources

- **When is Basic Authorization used vs. Bearer Authorization?**
  - Basic authorization is data encoded using base-64. This should always be in conjunction with a stronger form of encryption, and over a secure network, as basic alone can easily be decoded. When the server verifies that the user is authorized to access the requested web page, it passes an encrypted token only known to the program back to the client. The client then uses this token along with the credentials to access the requested page. This should be used for things such as financial transactions and other highly sensitive data.
  - Resource: [stack overflow](https://stackoverflow.com/questions/34013299/web-api-authentication-basic-vs-bearer#:~:text=2%20Answers&text=The%20Basic%20and%20Digest%20authentication,is%20described%20by%20the%20RFC6750.)
- **What does the JSON Web Token package do?**
  - The JSON Web Token package is a system for error-first callback. If no error is thrown, the web token will be converted into string and the authorization process will proceed. It also handles situations that instead expect base64 encoded secrets.
  - Resource: [npmjs.com](https://www.npmjs.com/package/jsonwebtoken)

- **What considerations should we make when creating and storing a SECRET?**
  - Store secrets in files ignored by source control systems
  - Using a secrets syncing service
  - Don't share secrets unencrypted in messaging systems
  - restrict API access and permissions
    - Keep a list of accepted IP addresses so that only requests from trusted sources are approved
  - encrypt before storing
  - **Resources**
    - [Medium](https://medium.com/poka-techblog/the-best-way-to-store-secrets-in-your-app-is-not-to-store-secrets-in-your-app-308a6807d3ed)
    - [GitGuardian](https://blog.gitguardian.com/secrets-api-management/#avoid-git-add)
    - [GitHub Docs](https://docs.github.com/en/actions/reference/encrypted-secrets)

### [Back to home](https://dcalhoun286.github.io/reading-notes/)
